
const { google } = require("googleapis");
const { GoogleGenerativeAI } = require("@google/generative-ai");
const { Queue, Worker } = require("bullmq"); // Import Queue and Worker from bullmq
const { Redis } = require("ioredis");
const axios = require("axios");




const connection = new Redis({
  port: 18809,
  host: "redis-18809.c261.us-east-1-4.ec2.cloud.redislabs.com",
  username: "default",
  password: "doWfwCCikPDhFWW5C5xBwrozn1qUSEoT",
  maxRetriesPerRequest: null,
});

const genAI = new GoogleGenerativeAI(process.env.API_KEY);

const queue = new Queue("gmail-auto-reply-queue", {
  connection: connection,
});

const gmailHandler = async (req, res) => {
  const { accessToken, refreshToken } = req.user.tokens;

  const oauth2Client = new google.auth.OAuth2(
    process.env.GOOGLE_CLIENT_ID,
    process.env.GOOGLE_CLIENT_SECRET,
    "http://localhost:3000/auth/google/callback"
  );

  oauth2Client.setCredentials({
    access_token: accessToken,
    refresh_token: refreshToken,
  });

  const gmail = google.gmail({
    version: "v1",
    auth: oauth2Client,
  });

  try {
    const response = await gmail.users.messages.list({
      userId: "me",
      q: "is:unread",
    });

    const messages = response.data.messages;
    if (messages.length === 0) {
      console.log("No unread emails found.");
      return res.status(200).send("No unread emails found.");
    }

    for (const message of messages) {
      const messageDetails = await gmail.users.messages.get({
        userId: "me",
        id: message.id,
        format: "full",
      });
      await sendAutoReply(gmail, messageDetails.data);
    }

    res.status(200).send("Auto reply enabled successfully!");
  } catch (error) {
    console.error("Error generating or sending reply message:", error);
    res
      .status(500)
      .send("Error generating or sending reply message: " + error.message);
  }
};


const categorizeEmail = async (email) => {
  try {
    const model = genAI.getGenerativeModel({ model: "gemini-pro" });

    const prompt = `You received an email with the subject: "${email.subject}" and the following content: "${email.body}". Please categorize this email into one of the following categories - Interested, Not Interested, More Information:`;

    const result = await model.generateContent(prompt);
    const response = await result.response;
    const category = await response.text();

    // Ensure the category is one of the expected values
    const validCategories = [
      "Interested",
      "Not Interested",
      "More Information",
    ];
    if (!validCategories.includes(category)) {
      throw new Error("Invalid category generated by AI model.");
    }

    return category;
  } catch (error) {
    console.error("Error categorizing email:", error);
    // Default category in case of error
    return "More Information";
  }
};


const sendAutoReply = async (gmail, messageDetails) => {
  const messageId = messageDetails.id;
  const emailSubject = messageDetails.payload.headers.find(
    (header) => header.name === "Subject"
  ).value;
  const emailBody = messageDetails.snippet;

  const category = await categorizeEmail({
    subject: emailSubject,
    body: emailBody,
  });
  console.log("Category:", category);

  let request = "";

  const extractNameFromEmail = (emailAddress) => {
    const match = emailAddress.match(/(.+?)\s?<.+>/); // Match the name part before the email address
    return match ? match[1] : emailAddress; // Return the matched name or the full email address if no match
  };

  const toName = extractNameFromEmail(
    messageDetails.payload.headers.find((header) => header.name === "To").value
  );
  const fromName = extractNameFromEmail(
    messageDetails.payload.headers.find((header) => header.name === "From")
      .value
  );

  // console.log(`printing name to : ${typeof (messageDetails.payload.headers.find((header) => header.name === "To").value)}  printing name from : ${messageDetails.payload.headers.find((header) => header.name === "From").value}`)
  switch (category) {
    case "Interested":
      request = `Read ${emailBody} and write an email on behalf of ${toName}, Reachinbox asking ${fromName} if they are willing to hop on to a demo call by suggesting a time from Mayank Pandey`;
      break;
    case "Not Interested":
      request = `Read ${emailBody} and write an email on behalf of ${toName}, Reachinbox thanking ${fromName} for their time and asking them if they would like to be contacted in the future from Mayank Pandey`;
      break;
    case "More Information":
      request = `Read ${emailBody} and write an email on behalf of ${toName}, Reachinbox asking ${fromName} if they would like more information about the product from Mayank Pandey`;
      break;
    default:
      request = `Read ${emailBody} and write an email on behalf of ${toName}, Reachinbox asking ${fromName} if they are willing to hop on to a demo call by suggesting a time Mayank Pandey`;
  }

  // Generate reply using AI model
  const model = genAI.getGenerativeModel({ model: "gemini-pro" });
  const prompt = `You received an email with the subject: "${emailSubject}" and the following content: "${emailBody}". ${request}`;

  const result = await model.generateContent(prompt);
  const response = await result.response;
  const generatedReply = await response.text();

  const rawMessage = Buffer.from(
    "To: " +
      messageDetails.payload.headers.find((header) => header.name === "From")
        .value +
      "\r\n" +
      "Subject: Re: " +
      emailSubject +
      "\r\n\r\n" +
      generatedReply
  ).toString("base64");

  await gmail.users.messages.send({
    userId: "me",
    requestBody: {
      raw: rawMessage,
    },
  });

  console.log("Reply sent successfully to email with id:", messageId);
};


const googleCallback = async (req, res) => {
  const { code } = req.query;
  if (!code) {
    return res.status(400).send("Authorization code missing.");
  }
  try {
    oAuth2Client.getToken(code, async function (err, tokens) {
      if (err) {
        console.error("Error getting oAuth tokens:", err);
      }
      oAuth2Client.setCredentials(tokens);

      const data = await getListOfMails(tokens);
      const messages = data.messages;
      const currentLabels = await axios.get(
        "https://gmail.googleapis.com/gmail/v1/users/me/labels",
        {
          headers: {
            Authorization: `Bearer ${tokens.access_token}`,
          },
        }
      );

      const existingLabelNames = currentLabels.data.labels.map(
        (label) => label.name
      );
      const labelsToCreate = [
        "Interested",
        "Not Interested",
        "More Information",
      ].filter((label) => !existingLabelNames.includes(label));

      const createLabelPromises = labelsToCreate.map(async (label) => {
        await limiter.schedule(async () => {
          return axios.post(
            `https://gmail.googleapis.com/gmail/v1/users/me/labels`,
            {
              name: label,
            },
            {
              headers: {
                Authorization: `Bearer ${tokens.access_token}`,
              },
            }
          );
        });
      });

      Promise.all(createLabelPromises)
        .then((responses) => {
          console.log("Labels created successfully:", responses);
        })
        .catch((error) => {
          console.error("Error creating labels:", error);
        });

      messages.forEach(async (message) => {
        await limiter.schedule(async () => {
          const id = message.id;
          const mail = await getMail(id, tokens);
          const parsedMail = parseMail(mail);
          console.log(parsedMail);
          const label = await labelMail(tokens, id, parsedMail);
          console.log(label);
          let request = "";
          switch (label) {
            case "Interested":
              request = `Read ${parsedMail.emailContext} and write an email on behalf of Mayank Pandey,Reachinbox asking ${parsedMail.from.name}  if they are willing to hop on to a demo call by suggesting a time from Mayank Pandey`;
              break;
            case "Not Interested":
              request = `Read ${parsedMail.emailContext} and write an email on behalf of Mayank Pandey, Reachinbox thanking ${parsedMail.from.name} for their time and asking them if they would like to be contacted in the future from Mayank Pandey`;
              break;
            case "More information":
              request = `Read ${parsedMail.emailContext} and write an email on behalf of Mayank Pandey, Reachinbox asking ${parsedMail.from.name} if they would like more information about the product from Mayank Pandey`;
              break;
            default:
              request = `Read ${parsedMail.emailContext} and write an email on behalf of Mayank Pandey, Reachinbox asking ${parsedMail.from.name} if they are willing to hop on to a demo call by suggesting a time Mayank`;
          }

          setTimeout(async () => {
            const body = await writeMail(request);
            const details = {
              to: parsedMail.from.email,
              cc: parsedMail.cc,
              subject: parsedMail.subject,
              body: body,
            };
            init(details);
          }, 2000);
        });
      });
      res.send(
        `You have successfully authenticated with Google and Sent Replies to your Email. You can now close this tab.`
      );
    });
  } catch (error) {
    console.log(error);
  }
};



module.exports = {gmailHandler, googleCallback};